=======================================================================================
					The Basic
=======================================================================================
Routing
---------------------------------------------------------------------------------------
1. Какой класс отвечает за маршрутизацию? 
(Route)

2. Где расположены файлы маршрутизации? 
(В папке routes)

3. Как называется файл, который отвечает за маршрутизацию для веб интерфейса? 
(routes/web.php)

4. Маршруты для веб интерфейса, какая группа промежуточного по работает для них по-умолчанию?
web middleware group

5. Как называется файл, который отвечает за 
routes/api.php

6. routes/api.php , какая группа промежуточного по работает для них по-умолчанию?
api middleware group

7. The routes defined in routes/web.php may be accessed by entering the defined route's URL in your browser. For example, you may access the following route by navigating to http://your-app.test/user in your browser:

8.Routes defined in the routes/api.php file are nested within a route group by the RouteServiceProvider. Within this group, the /api URI prefix is automatically applied so you do not need to manually apply it to every route in the file. You may modify the prefix and other route group options by modifying your RouteServiceProvider class.

9. Назовите доступные методы для маршрутов?
Route::get($uri, $callback);
Route::post($uri, $callback);
Route::put($uri, $callback);
Route::patch($uri, $callback);
Route::delete($uri, $callback);
Route::options($uri, $callback);

10. Какой метод нужно использовать, чтобы ответить на запрос от разных методов?
match method
Route::match(['get', 'post'], '/', function () {
    //
});

11. Какой метод нужно использовать, чтобы маршрут обрабатывал все методы запроса?
any method
Route::any('/', function () {
    //
});

12. Что должно содержать каждая форма?
CSRF token field
<form method="POST" action="/profile">
    @csrf
    ...
</form>

13. Какой метод использовать чтобы перенаправить запрос?
Route::redirect method
Route::redirect('/here', '/there');

14. Какой http статус по-умолчанию возвращает метод перенапраления запроса?
302 status code.

15. Назовите http статусы и что они обозначают.

16. Как изменить http статус, который возвращает метод перенапраления запроса?
Передать его третим параметром.
Route::redirect('/here', '/there', 301);
Или использовать метод Route::permanentRedirect, который возвращает 301 код по-умолчанию
Route::permanentRedirect('/here', '/there');

17. Какие слова нельзя использовать, если вы применяете метод перенапраления?
destination and status.

18. Напишите базовый пример ответа по 'foo' маршруту (базовый - Closure)
Route::get('foo', function () {
    return 'Hello World';
});

19. Что если ваш маршрут должен возвращать представление? какой метод вызвать?
Route::view('/welcome', 'welcome', ['name' => 'Taylor']);

20. Какие слова нельзя использовать с методом маршрута который возвращает представление?
view, data, status, and headers.

21. Как получить данные из URI?
Вы можете сделать это, указав параметры маршрута:
Route::get('posts/{post}/comments/{comment}', function ($postId, $commentId) {
    //
});
Параметры передаются callback function, название параметров в функции не имеет значение, переменные присываются в таком же порядке как и в url идут.

22. Правила для параметров маршрута?
Параметры маршрута всегда заключаются в фигурные скобки {} и должны состоять из буквенных символов и не могут содержать символа -. Вместо символа - используйте подчеркивание (_). 

23. Чем параметры маршрута отличаются от дополнительных параметров маршрута?
Если параметр является дополнительным - то он может не присутсовать в url, а может присутствовать, поэтому он дополнительный или опциональный.

24. Как задать дополнительный/опциональный параметр маршрута?
Нужно добавить знак вопроса, а также задать значение по-умолчанию в callback function.
Route::get('user/{name?}', function ($name = 'John') {
    return $name;
});

25. Как можно задать ограничения для параметром маршрута?
а) Можно использовать where метод в экземпляре маршрута. Метод where принимает имя параметра и регулярное выражение, определяющее, как параметр должен быть ограничен:
Route::get('user/{id}', function ($id) {
    //
})->where('id', '[0-9]+');

Route::get('user/{id}/{name}', function ($id, $name) {
    //
})->where(['id' => '[0-9]+', 'name' => '[a-z]+']);

б) Также для часто встречающихся шаблонов есть вспомогательные методы, которые позволяют быстро добавлять ограничения шаблонов к вашим маршрутам.
Route::get('user/{id}/{name}', function ($id, $name) {
    //
})->whereNumeric('id')->whereAlpha('name');

Route::get('user/{id}', function ($id) {
    //
})->whereUuid('id');

в) Также можго задать глобальные ограничения, если вы хотите чтобы параметр маршрута всегда ограничивался тем или иным регулярным выражением. Вы должны определить эти шаблоны в методе загрузки вашего RouteServiceProvider:
public function boot()
{
    Route::pattern('id', '[0-9]+');
}
Как только шаблон определен, он автоматически применяется ко всем маршрутам, использующим это имя параметра.
Route::get('user/{id}', function ($id) {
    // Only executed if {id} is numeric...
});

26.  Что такое именованные роуты и зачем они нужны?
Они позволяют задавать имена для маршрутов, которые потом удобно использовать создавая url адреса для того или иного маршрута.
Вы можете указать имя для маршрута, связав метод name с определением маршрута:
Route::get('user/profile', function () {
    //
})->name('profile');
Route::get('user/profile', [UserProfileController::class, 'show'])->name('profile');

27. Какие ограничения есть на именованные роуты?
Их имена должны быть уникальны.

28. Как можно сгенрировать urls для именованных уротов?
Если вы присволили имя роуту, он стал именованным роутом, вы можете использовать имя роута и глобальную функцию route().
return redirect()->route('profile');
Эту функцию удобно использовать в шаблонах, особенно если в базе данных есть поле с url_name для категории например.

29. А что если роут принимает параметры? 
В функцию route вторым параметром можно передать массив с данными.
Route::get('user/{id}/profile', function ($id) {
    //
})->name('profile');
$url = route('profile', ['id' => 1]);

30. А что если маршрут принимает 1 параметр а вы передадите 2 параметра?
Если вы передадите дополнительные параметры в массиве, эти пары ключ / значение будут автоматически добавлены в сгенерированную строку запроса URL:
Route::get('user/{id}/profile', function ($id) {
    //
})->name('profile');
$url = route('profile', ['id' => 1, 'photos' => 'yes']);
// /user/1/profile?photos=yes

31. Как определить что текущий запрос направлен на заданный именованный маршрут?
Вы можете использовать метод named в экземпляре Route.
/**
 * Handle an incoming request.
 *
 * @param  \Illuminate\Http\Request  $request
 * @param  \Closure  $next
 * @return mixed
 */
public function handle($request, Closure $next)
{
    if ($request->route()->named('profile')) {
        //
    }

    return $next($request);
}

32. Зачем нужны группы маршрутов?
Позволяют объединять маршруты в группы, и например использовать для них определенные промежуточное ПО, а не определеять для каждого отдельно.

33. Привидете пример использования группы маршрутов и промежуточное ПО?
Чтобы назначить промежуточное программное обеспечение для всех маршрутов в группе, вы можете использовать метод middleware перед определением группы. Промежуточное ПО выполняется в том порядке, в котором они перечислены в массиве:
Route::middleware(['first', 'second'])->group(function () {
    Route::get('/', function () {
        // Uses first & second middleware...
    });
    Route::get('user/profile', function () {
        // Uses first & second middleware...
    });
});

34. Как можно задать поддомен в машрутах?
Для группы маршрутов можно использовать поддоменную маршрутизацию. Поддомен можно указать, вызвав метод домена перед определением группы.
Route::domain('{account}.myapp.com')->group(function () {
    Route::get('user/{id}', function ($account, $id) {
        //
    });
});

35. Какие есть ограничения?
Чтобы обеспечить доступность маршрутов поддоменов, вы должны зарегистрировать маршруты поддоменов перед регистрацией маршрутов корневого домена. Это предотвратит перезапись маршрутами корневого домена маршрутов поддоменов, имеющих одинаковый путь URI.

Я так понял что субдомены должны идти перед обычными маршрутами?

36. Как задать префиксы к маршруту?
Также как и для субдоменов нужна група роутов.
Метод prefix может использоваться для префикса каждого маршрута в группе с заданным URI. 
Route::prefix('admin')->group(function () {
    Route::get('users', function () {
        // Matches The "/admin/users" URL
    });
});

37. Как добавить префикс для имени группе маршрутов?
Метод name может использоваться для добавления к каждому имени маршрута в группе префикса заданной строки. Например, вы можете захотеть добавить к всем именам сгруппированных маршрутов префикс admin. Данная строка имеет префикс к имени маршрута точно в том виде, в котором он указан, поэтому мы обязательно предоставим завершение. символ в префиксе:
Route::name('admin.')->group(function () {
    Route::get('users', function () {
        // Route assigned name "admin.users"...
    })->name('users');
});

38. Как можно связать модель с маршрутом?
Часто в маршрутах вы будете запрашивать модель, например, если вам нужен индефикатор для какого-то поста. Можно привязать модель к машруту, это обеспечивает автоматическое внедрение экземпляров модели в маршруты.
Вместо того, чтобы вводить индефикатор пользователя, вы можете внедрить экземпляр модели Пользователя, который соовествует данному индефикатору.

Связывая параметр маршрута с моделью, Laravel автоматически вместо параметра в callback function внедрит экземпляр модели, индефикатор которого совпадает с соответствующим значением из URI запроса (ну или не индефикатора - можно настроить).
То есть вам будет не просто приходить id, а уже по нему вы будуту обращаться в базу данных. Вам будет сразу приходить экземпляр нужного вам класса, в котором будет нужна запись/записи.

Тут нужно будет перечислить типо:
Implicit Binding
.....

39. Что такое Неявная привязка?
Laravel автоматически внедрит экземпляр модели, идентификатор которого совпадает с соответствующим значением из URI запроса. Если соответствующий экземпляр модели не найден в базе данных, автоматически будет сгенерирован HTTP-ответ 404.
Пример 1.
Route::get('api/users/{user}', function (App\Models\User $user) {
    return $user->email;
});
Пример 2.
use App\Http\Controllers\UserController;
use App\Models\User;
Route::get('users/{user}', [UserController::class, 'show']);
public function show(User $user)
{
    return view('user.profile', ['user' => $user]);
}

40. Что будет если вы привязали параметр машрута к определенной модели и по данному запросу не будет найдены нужные данные в бд?
Если соответствующий экземпляр модели не найден в базе данных, автоматически будет сгенерирован HTTP-ответ 404.

41. Если мы связываем параметр в машруте и модель, по какому полю по-умолчанию ищется запись?
id.
Кстати, а если мы поменяли поле по-умолчанию в самой модели. Например оно называется не id а как-то по другому, или в laravel поменяли, то что будет?

42. Можно ли поменять ключ по-которому ищется поле в базе данных, если у нас связан параметр и модель? 
Да, можно. Для этого вы можете указать столбец в определении параметра маршрута:
Route::get('api/posts/{post:slug}', function (App\Models\Post $post) {
    return $post;
});

43.
https://laravel.com/docs/8.x/routing#implicit-model-binding-scoping

44. Можно ли сделать, что если мы привязываем параметр в маршруте и модель, искался определенный столбец без указания его в параметре?
Если вы хотите, чтобы привязка модели использовала столбец базы данных по умолчанию, отличный от id, при извлечении данного класса модели, вы можете переопределить метод getRouteKeyName в модели Eloquent:
/**
 * Get the route key for the model.
 *
 * @return string
 */
public function getRouteKeyName()
{
    return 'slug';
}

45. Как сделать явную привязку? 
Чтобы зарегистрировать явную привязку, используйте метод model маршрутизатора, чтобы указать класс для данного параметра. Вы должны определить свои явные привязки модели в начале метода boot вашего класса RouteServiceProvider:
/**
 * Define your route model bindings, pattern filters, etc.
 *
 * @return void
 */
public function boot()
{
    Route::model('user', \App\Models\User::class);

    // ...
}
Route::get('profile/{user}', function (App\Models\User $user) {
    //
});
Я не понял и зачем это нужно? разве без boot не будет работать?

46. Чем явная привязка отличается от неявной привязки?

47. Как сделать неявную привязку?

48. Как можно настроить логику разрешения?
Если вы хотите использовать свою собственную логику разрешения, вы можете использовать метод Route :: bind. Замыкание, которое вы передаете методу привязки, получит значение сегмента URI и должно вернуть экземпляр класса, который должен быть введен в маршрут:
/**
 * Define your route model bindings, pattern filters, etc.
 *
 * @return void
 */
public function boot()
{
    Route::bind('user', function ($value) {
        return App\Models\User::where('name', $value)->firstOrFail();
    });

    // ...
}
Альтернатива:
 вы можете переопределить метод resolveRouteBinding в своей модели Eloquent. Этот метод получит значение сегмента URI и должен вернуть экземпляр класса, который должен быть введен в маршрут
 /**
 * Retrieve the model for a bound value.
 *
 * @param  mixed  $value
 * @param  string|null  $field
 * @return \Illuminate\Database\Eloquent\Model|null
 */
public function resolveRouteBinding($value, $field = null)
{
    return $this->where('name', $value)->firstOrFail();
}

49. Если в маршруте используется неявная область действия привязки, для разрешения дочерней привязки родительской модели будет использоваться метод?
resolveChildRouteBinding
/**
 * Retrieve the child model for a bound value.
 *
 * @param  string  $childType
 * @param  mixed  $value
 * @param  string|null  $field
 * @return \Illuminate\Database\Eloquent\Model|null
 */
public function resolveChildRouteBinding($childType, $value, $field)
{
    return parent::resolveChildRouteBinding($childType, $value, $field);
}

50. Как обрабатывать запросы, которые не подходят не под один маршрут?
Используя метод Route :: fallback, вы можете определить маршрут, который будет выполняться, когда ни один другой маршрут не соответствует входящему запросу. 
Как правило, необработанные запросы автоматически отображают страницу «404» через обработчик исключений вашего приложения. Однако, поскольку вы можете определить резервный маршрут в файле routes / web.php, все промежуточное ПО в группе промежуточного программного обеспечения Интернета будет применяться к этому маршруту. При необходимости вы можете добавить дополнительное ПО промежуточного слоя к этому маршруту:
Route::fallback(function () {
    //
});

51. Какое есть ограничения для fallback route?
Резервный маршрут всегда должен быть последним маршрутом, зарегистрированным вашим приложением.

52. Можно ли поставить лимит запросов?
вы можете использовать, чтобы ограничить объем трафика для данного маршрута или группы маршрутов. Для начала вы должны определить конфигурации ограничителя скорости, которые соответствуют потребностям вашего приложения. Как правило, это можно сделать в RouteServiceProvider вашего приложения.
Ограничители скорости определяются с помощью метода for фасада RateLimiter. Метод for принимает имя ограничителя скорости и закрытие, которое возвращает конфигурацию ограничения, которая должна применяться к маршрутам, которым назначен этот ограничитель скорости:
use Illuminate\Cache\RateLimiting\Limit;
use Illuminate\Support\Facades\RateLimiter;

RateLimiter::for('global', function (Request $request) {
    return Limit::perMinute(1000);
});

53. Что будет Если входящий запрос превышает указанный предел скорости?
Laravel автоматически вернет ответ с кодом состояния HTTP 429

54. Можно ли как-то поменять ответ, который приходит если входящий запрос превышает указанный предел скорости? Ответ, который будет присылать ограничитель скорости?
Если вы хотите определить свой собственный ответ, который должен возвращать ограничение скорости, вы можете использовать метод response:
RateLimiter::for('global', function (Request $request) {
    return Limit::perMinute(1000)->response(function () {
        return response('Custom response...', 429);
    });
});

55. Можно ли динамически задавать ограничения по скорости входящего трафика?
Поскольку обратные вызовы ограничителя скорости получают экземпляр входящего HTTP-запроса, вы можете динамически создать соответствующее ограничение скорости на основе входящего запроса или аутентифицированного пользователя:
RateLimiter::for('uploads', function (Request $request) {
    return $request->user()->vipCustomer()
                ? Limit::none()
                : Limit::perMinute(100);
});

56. 
https://laravel.com/docs/8.x/routing#segmenting-rate-limits

57.
https://laravel.com/docs/8.x/routing#multiple-rate-limits

58. Можно ли задать лимит скорости для определенных маршрутов?
Ограничители скорости могут быть присоединены к маршрутам или группам маршрутов с помощью промежуточного программного обеспечения throttle. Промежуточное программное обеспечение throttle принимает имя ограничителя скорости, которое вы хотите назначить маршруту:
Route::middleware(['throttle:uploads'])->group(function () {
    Route::post('/audio', function () {
        //
    });

    Route::post('/video', function () {
        //
    });
});
А то есть с помощью метода for мы задаем правила для ограничения скорости, а уже с помощью middleware задаем для какаих маршрутов?

59.
https://laravel.com/docs/8.x/routing#throttling-with-redis

60. Какие http методы поддерживают формы?

61. Какие http методы не поддерживают формы?

62. Что делать если нам нужно использовать определенный http метод но форма его не поддерживает? Как его задать?
HTML-формы не поддерживают действия PUT, PATCH или DELETE. Итак, при определении маршрутов PUT, PATCH или DELETE, которые вызываются из HTML-формы, вам нужно будет добавить в форму скрытое поле _method. Значение, отправленное с полем _method, будет использоваться в качестве метода HTTP-запроса:
<form action="/foo/bar" method="POST">
    <input type="hidden" name="_method" value="PUT">
    <input type="hidden" name="_token" value="{{ csrf_token() }}">
</form>
Альтернатива
Вы можете использовать директиву @method Blade для генерации ввода _method:
<form action="/foo/bar" method="POST">
    @method('PUT')
    @csrf
</form>

63. Как получить доступ к текущему маршруту?
Вы можете использовать методы current, currentRouteName и currentRouteAction фасада Route для доступа к информации о маршруте, обрабатывающем входящий запрос:
$route = Route::current();
$name = Route::currentRouteName();
$action = Route::currentRouteAction();

64.
65.
66.
67.
68.
69.
70.
71.
72.
73.
74.
75.
76.
77.
78.
79.
80.
81.
82.
83.
84.
85.
86.
87.
88.
89.
90.
91.
92.
93.
94.
95.
96.
97.
98.
99.
100.Напишите все возможные методы с роутами:
Тут нужно будет расписать типо
Route::get .... 
Route::redirect ./..
Route::view ....
И также написать что принимает в параметры
То есть все варианты должны с маршрутами быть описаны





=======================================================================================
Middleware
---------------------------------------------------------------------------------------
1. Зачем нужно промежуточное программное обеспечение/посредники?
Промежуточное ПО обеспечивает удобный механизм фильтрации HTTP-запросов, поступающих в ваше приложение. Они выполняют разнообразные функции от проверки авторизирован пользователь или нет до добавление заголовков к ответам.

2. Где хранятся посредники?
app/Http/Middleware directory.

3. Как создать нового посредника?
Чтобы создать новое промежуточное ПО, используйте Artisan-команду make: middleware:
php artisan make:middleware CheckAge
<?php

namespace App\Http\Middleware;

use Closure;

class CheckAge
{
    /**
     * Handle an incoming request.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Closure  $next
     * @return mixed
     */
    public function handle($request, Closure $next)
    {
        if ($request->age <= 200) {
            return redirect('home');
        }

        return $next($request);
    }
}

4. Что нужно помнить при использование посредников?
Посредники остонавливают запрос приходящий в приложение, поэтому его нужно передавтаь дальше.
Чтобы передать запрос глубже в приложение (позволяя промежуточному программному обеспечению «пройти»), вызовите обратный вызов $ next с помощью $ request.
Посредников можно представлять как слои, на которых содерживаются те или иные запросы. Каждый уровень может делать с запросом что угодно и даже полностью его отклонить.

5. Какие существуют типы посредников?
До и после посредники
Будет ли промежуточное ПО запускаться до или после запроса, зависит от самого промежуточного ПО.

Например, следующее промежуточное программное обеспечение выполнит некоторую задачу до того, как запрос будет обработан приложением:
class BeforeMiddleware
{
    public function handle($request, Closure $next)
    {
        // Perform action

        return $next($request);
    }
}

Однако это промежуточное ПО будет выполнять свою задачу после того, как запрос будет обработан приложением:
<?php
namespace App\Http\Middleware;
use Closure;
class AfterMiddleware
{
    public function handle($request, Closure $next)
    {
        $response = $next($request);
        // Perform action
        return $response;
    }
}

6. Как зарегистрировать посредника?
- Глобальный посредник
Если вы хотите, чтобы промежуточное ПО запускалось во время каждого HTTP-запроса к вашему приложению, укажите класс промежуточного ПО в свойстве $ middleware вашего класса app / Http / Kernel.php.
- Назначение посредников для маршрутов
Если вы хотите назначить посредника для определенных маршрутов, вы должны сначала назначить промежуточному программному обеспечению ключ в файле app / Http / Kernel.php. По умолчанию свойство $ routeMiddleware этого класса содержит записи для промежуточного программного обеспечения, включенного в Laravel. Чтобы добавить свой собственный, добавьте его в этот список и назначьте ему ключ по вашему выбору:
protected $routeMiddleware = [
	...
	'auth' => \App\Http\Middleware\Authenticate::class,
];
После определения посредника в ядре HTTP вы можете использовать метод middleware для назначения посредника для маршрута:
Route::get('/', function () {
    //
})->middleware('auth', 'first', 'second');
Альтернатива
use App\Http\Middleware\CheckAge;
Route::get('admin/profile', function () {
    //
})->middleware(CheckAge::class);
- Назначение посредников группе маршрутов
Route::middleware([CheckAge::class])->group(function () {
    Route::get('/', function () {
        //
    });

    Route::get('admin/profile', function () {
        //
    })
});
Альтернатива (тут это работает????)
Route::group(['middleware' => ['web']], function () {
    //
});

7. Что есть у вас задан посредник для группы маршрутов, но для какого-то из этих путей не нужно задавать посредника?
При назначении промежуточного программного обеспечения группе маршрутов иногда может потребоваться запретить применение промежуточного программного обеспечения к отдельному маршруту в группе. Вы можете сделать это с помощью метода withoutMiddleware:
use App\Http\Middleware\CheckAge;

Route::middleware([CheckAge::class])->group(function () {
    Route::get('/', function () {
        //
    });

    Route::get('admin/profile', function () {
        //
    })->withoutMiddleware([CheckAge::class]);
});

8. Особенность метода withoutMiddleware?
Метод withoutMiddleware может удалить только промежуточное ПО маршрутизации и не применяется к глобальному промежуточному ПО.

9. Зачем нужны группы посредников?
Иногда вам может потребоваться сгруппировать несколько промежуточных программ под одним ключом, чтобы упростить их назначение маршрутам. Вы можете сделать это, используя свойство $ middlewareGroups вашего HTTP-ядра.
protected $middlewareGroups = [
	...
];

10.Какие группы посредников вы знаете, которые включены из коробки?
В стандартной комплектации Laravel поставляется с группами промежуточного программного обеспечения веб и api, которые содержат общее промежуточное программное обеспечение, которое вы можете применить к своему веб-интерфейсу и маршрутам API:
protected $middlewareGroups = [
    'web' => [
	...
    ],

    'api' => [
	...
    ],
];

11. Как назначать группы посредников для маршрутов?
 с использованием того же синтаксиса, как и для одиночных посредников.
 Route::get('/', function () {
    //
})->middleware('web');

Route::group(['middleware' => ['web']], function () {
    //
});

Route::middleware(['web', 'subscribed'])->group(function () {
    //
});
 
12. Какая группа посредников автометически применяется для routes/web.php и кем?
web middleware group by the RouteServiceProvider.

13. Как отсортировать порядок применения посредников?
В этом случае вы можете указать свой приоритет промежуточного программного обеспечения, используя свойство $ middlewarePriority вашего файла app / Http / Kernel.php:
/**
 * The priority-sorted list of middleware.
 *
 * This forces non-global middleware to always be in the given order.
 *
 * @var array
 */
protected $middlewarePriority = [
    \Illuminate\Session\Middleware\StartSession::class,
    \Illuminate\View\Middleware\ShareErrorsFromSession::class,
    \Illuminate\Contracts\Auth\Middleware\AuthenticatesRequests::class,
    \Illuminate\Routing\Middleware\ThrottleRequests::class,
    \Illuminate\Session\Middleware\AuthenticateSession::class,
    \Illuminate\Routing\Middleware\SubstituteBindings::class,
    \Illuminate\Auth\Middleware\Authorize::class,
];

14. Можно ли посредникам передавать параметры как маршрутам?
Middleware также может получать дополнительные параметры.
Дополнительные параметры промежуточного программного обеспечения будут переданы промежуточному программному обеспечению после аргумента $ next:
<?php
namespace App\Http\Middleware;
use Closure;
class CheckRole
{
    /**
     * Handle the incoming request.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \Closure  $next
     * @param  string  $role
     * @return mixed
     */
    public function handle($request, Closure $next, $role)
    {
        if (! $request->user()->hasRole($role)) {
            // Redirect...
        }

        return $next($request);
    }

}
Параметры для посредников можно указать при определении маршрута, разделив имя посредника и параметры символом:. Несколько параметров следует разделять запятыми:
Route::put('post/{id}', function ($id) {
    //
})->middleware('role:editor');
Я не понял а где посредника написали? ????

15. 
https://laravel.com/docs/8.x/middleware#terminable-middleware

16.
17.
18.
19.
20.
21.
22.
23.
24.
25.
26.
27.
28.
29.
30.
21.
22.
23.
24.
25.
26.
27.
28.
29.
30.
31.
32.
33.
34.
35.
36.
37.
38.
39.
40.
41.
42.
43.
44.
45.
46.
47.
48.
49.
50.
51.
52.
53.
54.
55.
56.
57.
58.
59.
60.
61.
62.
63.
64.
65.
66.
67.
68.
69.
70.
71.
72.
73.
74.
75.
76.
77.
78.
79.
80.
81.
82.
83.
84.
85.
86.
87.
88.
89.
90.
91.
92.
93.
94.
95.
96.
97.
98.
99.
100.





=======================================================================================
CSRF Protection
---------------------------------------------------------------------------------------
1. Что такое CSRF attacks?
Подделка межсайтовых запросов - это разновидность вредоносного эксплойта, при котором неавторизованные команды выполняются от имени аутентифицированного пользователя.

2. Виды CSRF attacks?

3. Каким образом можно защититья от CSRF attacks?

4. Каким образом можно Laravel защищается от CSRF attacks? Какой механизм работы?
Laravel автоматически генерирует «токен» CSRF для каждой активной пользовательской сессии, управляемой приложением. Этот токен используется для проверки того, что аутентифицированный пользователь действительно делает запросы к приложению.

5. Назовите другие виды атак, как их реализуют, как от них защититься, как в ларевель защищает от них?

6. Когда вы определяете html форму, что нужно обязательно сделать?
Каждый раз, когда вы определяете HTML-форму в своем приложении, вы должны включать в форму скрытое поле токена CSRF, чтобы промежуточное ПО защиты CSRF могло проверить запрос. Вы можете использовать директиву @csrf Blade для создания поля токена:
<form method="POST" action="/profile">
    @csrf
    ...
</form>

7. Вы вставляете директиву @csrf в форму. Кто обрабатывает запрос из формы и проверяет этот токен?
ПО промежуточного слоя VerifyCsrfToken, которое входит в группу промежуточного программного обеспечения веб-сайтов, автоматически проверяет, соответствует ли токен во входных данных запроса токену, хранящемуся в сеансе.

8. 
https://laravel.com/docs/8.x/csrf#csrf-tokens-javascript

9. Как исключить uri из защиты csrf?
https://laravel.com/docs/8.x/csrf#csrf-excluding-uris

10.
https://laravel.com/docs/8.x/csrf#csrf-x-csrf-token

11.
https://laravel.com/docs/8.x/csrf#csrf-x-xsrf-token

12.
13. 
14.
15.
16.
17.
18.
19.
20.
21.
22.
23.
24.
25.
26.
27.
28.
29.
30.
21.
22.
23.
24.
25.
26.
27.
28.
29.
30.
31.
32.
33.
34.
35.
36.
37.
38.
39.
40.
41.
42.
43.
44.
45.
46.
47.
48.
49.
50.
51.
52.
53.
54.
55.
56.
57.
58.
59.
60.
61.
62.
63.
64.
65.
66.
67.
68.
69.
70.
71.
72.
73.
74.
75.
76.
77.
78.
79.
80.
81.
82.
83.
84.
85.
86.
87.
88.
89.
90.
91.
92.
93.
94.
95.
96.
97.
98.
99.
100.





=======================================================================================
Controllers
---------------------------------------------------------------------------------------
1. Зачем нужны контролеры? И где они храняться?
Чтобы вынести логику обработки запросов из замыканий в routes/web.php, в контролеры. То есть логику обработки запросов вы перекладываете на классы контролеров.
Контроллеры могут сгруппировать связанную логику обработки запросов в один класс. Контроллеры хранятся в каталоге app / Http / Controllers.

2. Что такое mvs? как она реализуется в ларавель
вообщем еще какие-нибудь такие общие вопросы. 
И вообще нужно дополнить тест общими вопросоми с тематми связанными с ларавель. 
Ну понятно, что это advanced уровень.

3. дополнительно
И вообще это классная стратегия:
я что-то изучаю
делаю записи -> делаю статьи.
Делаю тест
Таким образом я что-то изучил, у меня все это записано и я могу в любой момент времени почитать, при чем информация записана в понятном для меня в виде и моими словами, а далее могу проходить эти тесты раз в неделю и освежать свои знания.
Это сильный уровень и самый тяжелый.

4. От какого класса наследуется контролер?
namespace App\Http\Controllers;
use App\Http\Controllers\Controller;
class UserController extends Controller
{
	...
}
контроллер расширяет базовый класс контроллера, включенный в Laravel. 

5. Как определить маршрут к определенному действию у котрорлера?
use App\Http\Controllers\UserController;
Route::get('user/{id}', [UserController::class, 'show']);

6.Как определить контролер?
php artisan make:controller ShowProfile
Создается в папке...

7. Какие методы предоставляет базовый контролер?
Базовый класс предоставляет несколько удобных методов, таких как метод middleware, который можно использовать для присоединения промежуточного программного обеспечения к действиям контроллера. А также: validate and dispatch methods.
А еще????

8. Где хранятся контролеры?

9. Если у вашего контролера только одно действие, как вы его определите?
Если вы хотите определить контроллер, который обрабатывает только одно действие, вы можете поместить на контроллер единственный метод __invoke:
<?php

namespace App\Http\Controllers;

use App\Http\Controllers\Controller;
use App\Models\User;

class ShowProfile extends Controller
{
    /**
     * Show the profile for the given user.
     *
     * @param  int  $id
     * @return \Illuminate\View\View
     */
    public function __invoke($id)
    {
        return view('user.profile', ['user' => User::findOrFail($id)]);
    }
}

10. Особенность регистрации маршрута для контролера с одним действием?
При регистрации маршрутов для контроллеров одиночного действия вам не нужно указывать метод:
use App\Http\Controllers\ShowProfile;
Route::get('user/{id}', ShowProfile::class);

11. Как можно сгенрировать контролер с одним действие?
Вы можете сгенерировать  контроллер с одним действием, используя параметр --invokable Artisan-команды make: controller:
php artisan make:controller ShowProfile --invokable

12. Как применить посредников для контролеров?
Способ А
Route::get('profile', [UserController::class, 'show'])->middleware('auth');
Способ Б (он же лучший)
Однако удобнее указать посредников в конструкторе вашего контроллера. Используя метод middleware из конструктора вашего контроллера, вы можете легко назначить посредников для действия контроллера. Вы даже можете ограничить посредников только определенными методами в классе контроллера:
class UserController extends Controller
{
    /**
     * Instantiate a new controller instance.
     *
     * @return void
     */
    public function __construct()
    {
        $this->middleware('auth');

        $this->middleware('log')->only('index');

        $this->middleware('subscribed')->except('store');
    }
}
Способ С.
Контроллеры также позволяют регистрировать посредников с помощью Closure. Это обеспечивает удобный способ определения промежуточного программного обеспечения для одного контроллера без определения всего класса промежуточного программного обеспечения:
$this->middleware(function ($request, $next) {
    // ...

    return $next($request);
});
Не понял куда это писать.

13. Когда создавать контролер, когда модель а когда представление?

14. Когда создавать контролер? Когда лучше разбить контролер

15. Паттерны проектирования которые исплются laravel
например eluqonte orm

16. Вопросы про бд еще нужны)

17. Что такое контролеры ресурсов?
Маршрутизация ресурсов Laravel назначает типичные маршруты «CRUD» контроллеру с помощью одной строки кода. Например, вы можете захотеть создать контроллер, который будет обрабатывать все HTTP-запросы для «фотографий», хранящихся в вашем приложении. 

18. Как создать контролер ресурсов?
Используя Artisan-команду make: controller, мы можем быстро создать такой контроллер:
php artisan make:controller PhotoController --resource

19. Что такое CRUD контролеры?

20. Где хранятся контролеры?
app/Http/Controllers/PhotoController.php

21. Преимущества контролеров ресурсов?
Контроллер будет содержать метод для каждой из доступных операций с ресурсами.

22. Каким образом можно зарегистрировать эффективный маршрут к контролеру ресурсов?
Route::resource('photos', PhotoController::class);
Это единственное объявление маршрута создает несколько маршрутов для обработки множества действий с ресурсом. Сгенерированный контроллер уже будет иметь методы, заглушенные для каждого из этих действий, включая примечания, информирующие вас о HTTP-командах и URI, которые они обрабатывают.

23. Как можно зарегистрировать сразу несколько контролеров ресурсов?
Вы можете зарегистрировать сразу несколько контроллеров ресурсов, передав массив методу ресурсов:
Route::resources([
    'photos' => PhotoController::class,
    'posts' => PostController::class,
]);

24. Действия, выполняемые контроллером ресурсов.
https://laravel.com/docs/8.x/controllers#actions-handled-by-resource-controller
 
25. Определение модели для контролеров ресурсов?
Если вы используете привязку модели маршрута и хотите, чтобы методы контроллера ресурсов указывали тип экземпляра модели, вы можете использовать параметр --model при создании контроллера:
php artisan make:controller PhotoController --resource --model=Photo

26. Артизан и его команды
Кстати с ним реально надо хорошо повозится и выучить. Это очень удобная cli, которая с помощью пару команд уменьшает количество набераемого кода вручную.
Также хорош и удобен как git, когда его выучишь.

27. Как определить частичные маршруты для контролеров ресурсов?
При объявлении маршрута ресурса вы можете указать подмножество действий, которые должен обрабатывать контроллер, вместо полного набора действий по умолчанию:
Route::resource('photos', PhotoController::class)->only([
    'index', 'show'
]);
Route::resource('photos', PhotoController::class)->except([
    'create', 'store', 'update', 'destroy'
]);
 
28. 
https://laravel.com/docs/8.x/controllers#api-resource-routes

29. Как работать с вложенные ресурсы?
Иногда вам может потребоваться определить маршруты к вложенному ресурсу. Чтобы вложить контроллеры ресурсов, используйте нотацию с точкой в объявлении маршрута:
Route::resource('photos.comments', PhotoCommentController::class);
Этот маршрут зарегистрирует вложенный ресурс, к которому можно получить доступ с помощью URI, подобных следующим:
/photos/{photo}/comments/{comment}

30. 
https://laravel.com/docs/8.x/controllers#scoping-nested-resources

21.
https://laravel.com/docs/8.x/controllers#shallow-nesting

22. Каким образом можно именовать маршруты контролеров ресурсов?
По умолчанию все действия контроллера ресурсов имеют имя маршрута; однако вы можете переопределить эти имена, передав массив имен с вашими параметрами:
Route::resource('photos', PhotoController::class)->names([
    'create' => 'photos.build'
]);

23.
https://laravel.com/docs/8.x/controllers#restful-naming-resource-route-parameters

24.
https://laravel.com/docs/8.x/controllers#restful-scoping-resource-routes

25.
https://laravel.com/docs/8.x/controllers#restful-localizing-resource-uris

26.
https://laravel.com/docs/8.x/controllers#restful-supplementing-resource-controllers

27.
https://laravel.com/docs/8.x/controllers#dependency-injection-and-controllers
фулл главу прпоустил 

28.
https://laravel.com/docs/8.x/controllers#route-caching
фулл главу прпоустил 

29.
30.
31.
32.
33.
34.
35.
36.
37.
38.
39.
40.
41.
42.
43.
44.
45.
46.
47.
48.
49.
50.
51.
52.
53.
54.
55.
56.
57.
58.
59.
60.
61.
62.
63.
64.
65.
66.
67.
68.
69.
70.
71.
72.
73.
74.
75.
76.
77.
78.
79.
80.
81.
82.
83.
84.
85.
86.
87.
88.
89.
90.
91.
92.
93.
94.
95.
96.
97.
98.
99.
100.





=======================================================================================
HTTP Requests
---------------------------------------------------------------------------------------
1. Как получить доступ к запросу?
Чтобы получить экземпляр текущего HTTP-запроса через внедрение зависимостей, вы должны ввести класс Illuminate \ Http \ Request в методе вашего контроллера. Экземпляр входящего запроса будет автоматически внедрен контейнером службы:
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class UserController extends Controller
{
    /**
     * Store a new user.
     *
     * @param  Request  $request
     * @return Response
     */
    public function store(Request $request)
    {
        $name = $request->input('name');

        //
    }
}

2. В чем разница между requist и параметрами в маршрутах? Как получать данные из запроса в первом и втором случае? 
requist я так понял это формы и таким образом можно получить доступ к запросам
а для параметров нужно указывать в callback function параметры, которые будут их получать.

Если ваш метод контроллера также ожидает ввода от параметра маршрута, вы должны указать параметры маршрута после других зависимостей. Например, если ваш маршрут определен так:
use App\Http\Controllers\UserController;
Route::put('user/{id}', [UserController::class, 'update']);
Вы по-прежнему можете ввести Illuminate \ Http \ Request и получить доступ к своему идентификатору параметра маршрута, определив свой метод контроллера следующим образом:
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;

class UserController extends Controller
{
    /**
     * Update the specified user.
     *
     * @param  Request  $request
     * @param  string  $id
     * @return Response
     */
    public function update(Request $request, $id)
    {
        //
    }
}

3. Назовите методы которые предоставляет Экземпляр Illuminate \ Http \ Request для проверки HTTP-запроса для вашего приложения?
- Получение пути запроса
Метод path возвращает информацию о пути запроса. Итак, если входящий запрос нацелен на http://domain.com/foo/bar, метод пути вернет foo / bar:
$uri = $request->path();
- чтобы убедиться, что путь входящего запроса соответствует заданному шаблону.
is method
if ($request->is('admin/*')) {
    //
}
При использовании этого метода вы можете использовать символ * как подстановочный знак
- Получение URL-адреса запроса
Чтобы получить полный URL-адрес входящего запроса, вы можете использовать методы url или fullUrl. Метод url вернет URL без строки запроса, а метод fullUrl включает строку запроса:
// Without Query String...
$url = $request->url();
// With Query String...
$url = $request->fullUrl();
- Получение метода запроса
Метод method вернет HTTP-команду для запроса. Вы можете использовать метод isMethod, чтобы убедиться, что HTTP-команда соответствует заданной строке:
$method = $request->method();
if ($request->isMethod('post')) {
    //
}

А еще?

4. 
https://laravel.com/docs/8.x/requests#psr7-requests

5.
https://laravel.com/docs/8.x/requests#input-trimming-and-normalization

6. Каким образом можно получить ввод пользователя в форме? Какие есть методы?
- Получение всех входных данных
Вы также можете получить все входные данные в виде массива, используя метод all:
$input = $request->all();
- Получение входного значения
Используя несколько простых методов, вы можете получить доступ ко всему пользовательскому вводу из вашего экземпляра Illuminate \ Http \ Request, не беспокоясь о том, какой HTTP-глагол использовался для запроса. Независимо от HTTP-глагола, для получения пользовательского ввода может использоваться метод ввода:
$name = $request->input('name');
Вы можете передать значение по умолчанию в качестве второго аргумента метода ввода. Это значение будет возвращено, если запрошенное входное значение отсутствует в запросе:
$name = $request->input('name', 'Sally');
- При работе с формами, которые содержат входные данные массива, используйте "точечную" нотацию для доступа к массивам:
$name = $request->input('products.0.name');
$names = $request->input('products.*.name');
- Вы можете вызвать метод ввода без каких-либо аргументов, чтобы получить все входные значения в виде ассоциативного массива:
$input = $request->input();
- Получение ввода из строки запроса
https://laravel.com/docs/8.x/requests#retrieving-input-from-the-query-string

вообщем я тут оставился. Дальше пока не буду. Потому что я опять перевожу. Лучше все подготовить выучить и перепистаь и уже затем делать тест


7.
8.
9.
10.
11.
12.
13. 
14.
15.
16.
17.
18.
19.
20.
21.
22.
23.
24.
25.
26.
27.
28.
29.
30.
21.
22.
23.
24.
25.
26.
27.
28.
29.
30.
31.
32.
33.
34.
35.
36.
37.
38.
39.
40.
41.
42.
43.
44.
45.
46.
47.
48.
49.
50.
51.
52.
53.
54.
55.
56.
57.
58.
59.
60.
61.
62.
63.
64.
65.
66.
67.
68.
69.
70.
71.
72.
73.
74.
75.
76.
77.
78.
79.
80.
81.
82.
83.
84.
85.
86.
87.
88.
89.
90.
91.
92.
93.
94.
95.
96.
97.
98.
99.
100.
































































=======================================================================================

---------------------------------------------------------------------------------------
1.
2.
3.
4.
5.
6.
7.
8.
9.
10.
11.
12.
13. 
14.
15.
16.
17.
18.
19.
20.
21.
22.
23.
24.
25.
26.
27.
28.
29.
30.
31.
32.
33.
34.
35.
36.
37.
38.
39.
40.
41.
42.
43.
44.
45.
46.
47.
48.
49.
50.
51.
52.
53.
54.
55.
56.
57.
58.
59.
60.
61.
62.
63.
64.
65.
66.
67.
68.
69.
70.
71.
72.
73.
74.
75.
76.
77.
78.
79.
80.
81.
82.
83.
84.
85.
86.
87.
88.
89.
90.
91.
92.
93.
94.
95.
96.
97.
98.
99.
100.















=======================================================================================
































































