=======================================================================================
Blade Templates
---------------------------------------------------------------------------------------
1. Какой шаблнозатор поставляется вместе с Laravel?
Blade
2. Во что компилируются blade шаблоны?
В php code
3. Расширение для blade шаблонов?
blade.php
4. Где хранятся шаблоны,
resources/views
5. Преимущества использования blade шаблонов?
Наследование шаблонов и секции
6. Какая директивая определяет секцию содержимого?
@section
7. Какая директива используется для отображения содержимого заданной секции
@yield('content')
        @section('content')
            This is the master sidebar.
        @show
8. Вы определили общий макет для всех наблонов, как указатиь что данный шаблон лдочерний?
При определении дочернего шаблона используйте Blade-директиву @extends для указания макета, который должен быть "унаследован" дочерним шаблоном.
@extends('layouts.app')
9. Обычно общий шаблон для других шаблонов называется макет и хранится в 
recourses/views/layouts
10. Каким образом можно передать title в макет?
макет:
@yield('title')
шаблон:
@section('title', 'Page Title')
11. К примеру есть секция в макете @section('sidebar')...@show. Каким образом добавить из дочернего шаблона что-то в sidebar секцию?
@section('sidebar')
    @parent

    <p>This is appended to the master sidebar.</p>
@endsection
Использовать директиву @parent для дополнения (а не перезаписи) содержимого к боковой панели макета. Директива @parent будет заменена содержимым макета при отрисовке шаблона.
12. В чем разница между: секция sidebar заканчивается на @endsection вместо @show?
Директива @endsection будет только определять секцию, в то время как @show будет определять и немедленно вставлять секцию
13. КАк получить шаблон из маршрутов?
Blade-шаблоны могут быть возвращены из роутов при помощи глобального хелпера view
14. Как передать значение в директиву @yield по-умолчанию?
Директива @yield также принимает значение по умолчанию в качестве второго параметра. Это значение будет отображено, если получаемый раздел не определен:
@yield('content', View::make('view.name'))
15. Как передавать данные в шаблон?
Route::get('greeting', function () {
    return view('welcome', ['name' => 'Samantha']);
});
Или использовать compact(), куда передается имена переменных.
16. Как можно отобразить содержимое переменной в шаблоне?
{{ $name }}
17. Операторы Blade {{}} автоматически вызываетс функцию?
PHP htmlspecialchars для предотвращения атак XSS.
18. Что можно писать внутри {{}}?
php code
19. Как отобразить неэкранированные данные
По умолчанию операторы Blade {{}} автоматически отправляются через функцию PHP htmlspecialchars, чтобы предотвратить атаки XSS. Если вы не хотите, чтобы ваши данные были экранированы, вы можете использовать следующий синтаксис:
Hello, {!! $name !!}.
Всегда используйте экранированный синтаксис двойной фигурной скобки, чтобы предотвратить атаки XSS при отображении данных, предоставленных пользователем.
20.json 

21.Кодировка HTML-объекта

22.Blade & JavaScript Frameworks

23. Назовите управляющие конструкции в blade?
If Statements
Вы можете создавать операторы if, используя директивы @if, @elseif, @else и @endif. Эти директивы работают так же, как и их аналоги в PHP:
@if (count($records) === 1)
    I have one record!
@elseif (count($records) > 1)
    I have multiple records!
@else
    I don't have any records!
@endif
Для удобства Blade также предоставляет директиву @unless:
@unless (Auth::check())
    You are not signed in.
@endunless
В дополнение к уже обсужденным условным директивам директивы @isset и @empty могут использоваться как удобные ярлыки для соответствующих функций PHP:
@isset($records)
    // $records is defined and is not null...
@endisset

@empty($records)
    // $records is "empty"...
@endempty

Authentication Directives
Директивы @auth и @guest могут использоваться для быстрого определения, аутентифицирован ли текущий пользователь или является гостем:
@auth
    // The user is authenticated...
@endauth

@guest
    // The user is not authenticated...
@endguest
При необходимости вы можете указать защиту аутентификации, которую следует проверять при использовании директив @auth и @guest:
@auth('admin')
    // The user is authenticated...
@endauth

@guest('admin')
    // The user is not authenticated...
@endguest

Section Directives
Вы можете проверить, есть ли в разделе контент, используя директиву @hasSection:
@hasSection('navigation')
    <div class="pull-right">
        @yield('navigation')
    </div>

    <div class="clearfix"></div>
@endif
Вы можете использовать директиву sectionMissing, чтобы определить, нет ли в разделе содержимого:
@sectionMissing('navigation')
    <div class="pull-right">
        @include('default-navigation')
    </div>
@endif

Environment Directives
Вы можете проверить, работает ли приложение в производственной среде, с помощью директивы @production:
@production
    // Production specific content...
@endproduction
Или вы можете определить, работает ли приложение в определенной среде, с помощью директивы @env:
@env('staging')
    // The application is running in "staging"...
@endenv

@env(['staging', 'production'])
    // The application is running in "staging" or "production"...
@endenv

Switch Statements
Операторы переключения могут быть созданы с помощью директив @switch, @case, @break, @default и @endswitch:
@switch($i)
    @case(1)
        First case...
        @break

    @case(2)
        Second case...
        @break

    @default
        Default case...
@endswitch

Loops
В дополнение к условным операторам Blade предоставляет простые директивы для работы со структурами циклов PHP. Опять же, каждая из этих директив функционирует идентично своим аналогам PHP:
@for ($i = 0; $i < 10; $i++)
    The current value is {{ $i }}
@endfor

@foreach ($users as $user)
    <p>This is user {{ $user->id }}</p>
@endforeach

@forelse ($users as $user)
    <li>{{ $user->name }}</li>
@empty
    <p>No users</p>
@endforelse

@while (true)
    <p>I'm looping forever.</p>
@endwhile
При создании цикла вы можете использовать переменную цикла, чтобы получить ценную информацию о цикле, например, находитесь ли вы на первой или последней итерации цикла.
При использовании циклов вы также можете завершить цикл или пропустить текущую итерацию:
@foreach ($users as $user)
    @if ($user->type == 1)
        @continue
    @endif

    <li>{{ $user->name }}</li>

    @if ($user->number == 5)
        @break
    @endif
@endforeach
Вы также можете включить условие с объявлением директивы в одну строку:
@foreach ($users as $user)
    @continue($user->type == 1)

    <li>{{ $user->name }}</li>

    @break($user->number == 5)
@endforeach

The Loop Variable
При работе с циклами внутри цикла будет доступна переменная $loop. Эта переменная предоставляет доступ к некоторым полезным данным, например, текущий индекс цикла, или находитесь ли вы на первой или последней итерации цикла:
@foreach ($users as $user)
    @if ($loop->first)
        This is the first iteration.
    @endif

    @if ($loop->last)
        This is the last iteration.
    @endif

    <p>This is user {{ $user->id }}</p>
@endforeach
Если вы находитесь во вложенном цикле, вы можете получить доступ к переменной $ loop родительского цикла через свойство parent:
@foreach ($users as $user)
    @foreach ($user->posts as $post)
        @if ($loop->parent->first)
            This is first iteration of the parent loop.
        @endif
    @endforeach
@endforeach

24. Назовите Переменная $loop одержит также множество других полезных свойств
табличца

25. Комментарии 
Blade также позволяет вам определить комментарии в ваших шаблонах. Но в отличие от HTML-комментариев, Blade-комментарии не включаются в HTML-код, возвращаемый вашим приложением:
{{-- Этого комментария не будет в итоговом HTML --}}

26. В некоторых ситуациях полезно встраивать PHP-код в ваши представления.
Вы можете использовать директиву Blade @php для выполнения блока простого PHP в вашем шаблоне:
@php
    //
@endphp

27. The @once Directive
Директива @once позволяет вам определять часть шаблона, которая будет оцениваться только один раз за цикл рендеринга. Это может быть полезно для вставки заданного фрагмента JavaScript в заголовок страницы с помощью стеков. Например, если вы визуализируете данный компонент в цикле, вы можете захотеть вставить JavaScript в заголовок только при первой визуализации компонента:
@once
    @push('scripts')
        <script>
            // Your custom JavaScript...
        </script>
    @endpush
@endonce

28. Каждый раз, когда вы определяете HTML-форму в своем приложении, вы должны включать в форму скрытое поле?
скрытое поле токена CSRF, чтобы промежуточное ПО защиты CSRF могло проверить запрос. 
Вы можете использовать директиву @csrf Blade для создания поля токена:
<form method="POST" action="/profile">
    @csrf

    ...
</form>
29. Что такео csrf? токен? как защтитиься, как в ларавель защищает?

30. Поскольку HTML-формы не могут выполнять запросы PUT, PATCH или DELETE, вам нужно будет добавить скрытое поле _method для подмены этих HTTP-глаголов. Директива @method Blade может создать для вас это поле:
<form action="/foo/bar" method="POST">
    @method('PUT')

    ...
</form>

31. Validation Errors
Директива @error может использоваться для быстрой проверки наличия сообщений об ошибках проверки для данного атрибута. В директиве @error вы можете повторить переменную $ message, чтобы отобразить сообщение об ошибке:
<!-- /resources/views/post/create.blade.php -->

<label for="title">Post Title</label>

<input id="title" type="text" class="@error('title') is-invalid @enderror">

@error('title')
    <div class="alert alert-danger">{{ $message }}</div>
@enderror
Вы можете передать имя определенного пакета ошибок в качестве второго параметра директиве @error для получения сообщений об ошибках проверки на страницах, содержащих несколько форм:
<!-- /resources/views/auth.blade.php -->

<label for="email">Email address</label>

<input id="email" type="email" class="@error('email', 'login') is-invalid @enderror">

@error('email', 'login')
    <div class="alert alert-danger">{{ $message }}</div>
@enderror

32. Какие есть два подхода к написанию компонентов?
компоненты на основе классов и анонимные компоненты.

33. Как создать компонент на основе класса?
вы можете использовать Artisan-команду make: component

34. Куда помещаются компоненты на основе класса?
каталог App \ View \ Components:

35. Когда создается компонент класса, что еще создается? И где оно будет хранится?
также создаст шаблон представления для компонента.
Представление будет помещено в каталог resources / views / components.

36. Что нужно сделать после создания компаента? &&&&&&&&&&&&& xzxzxzz
зарегистрировать класс компонента и его псевдоним HTML-тега. Обычно вы должны зарегистрировать свои компоненты в методе boot поставщика услуг вашего пакета:
use Illuminate\Support\Facades\Blade;

/**
 * Bootstrap your package's services.
 */
public function boot()
{
    Blade::component('package-alert', AlertComponent::class);
}
После того, как ваш компонент был зарегистрирован, он может отображаться с использованием псевдонима тега:
<x-package-alert/>

37. Как отобразить компонент:
Для отображения компонента вы можете использовать тег компонента Blade в одном из ваших шаблонов Blade. Теги компонентов Blade начинаются со строки x-, за которой следует имя кебаба класса компонента:
<x-alert/>

38. Как отправлять данные в компонент?
Вы можете передавать данные компонентам Blade, используя атрибуты HTML.
Жестко запрограммированные примитивные значения могут быть переданы компоненту с помощью простых атрибутов HTML. Выражения и переменные PHP должны передаваться компоненту через атрибуты, которые используют символ: в качестве префикса:
<x-alert type="error" :message="$message"/>
Вы должны определить необходимые данные компонента в его конструкторе класса. Все общедоступные свойства компонента будут автоматически доступны в представлении компонента. Нет необходимости передавать данные в представление из метода render компонента:
<?php

namespace App\View\Components;

use Illuminate\View\Component;

class Alert extends Component
{
    /**
     * The alert type.
     *
     * @var string
     */
    public $type;

    /**
     * The alert message.
     *
     * @var string
     */
    public $message;

    /**
     * Create the component instance.
     *
     * @param  string  $type
     * @param  string  $message
     * @return void
     */
    public function __construct($type, $message)
    {
        $this->type = $type;
        $this->message = $message;
    }

    /**
     * Get the view / contents that represent the component.
     *
     * @return \Illuminate\View\View|\Closure|string
     */
    public function render()
    {
        return view('components.alert');
    }
}
Когда ваш компонент визуализируется, вы можете отображать содержимое общедоступных переменных вашего компонента, повторяя переменные по имени:
<div class="alert alert-{{ $type }}">
    {{ $message }}
</div>

39. Стиль для написания аргументов для компонентов?
Аргументы конструктора компонентов должны быть указаны с использованием camelCase, а kebab-case следует использовать при ссылке на имена аргументов в ваших атрибутах HTML.
$this->alertType = $alertType;
Аргумент $ alertType может быть предоставлен следующим образом:
<x-alert alert-type="danger" />

40. Методы компонентов?
В дополнение к общедоступным переменным, доступным для вашего шаблона компонента, также могут выполняться любые общедоступные методы компонента. Например, представьте компонент, у которого есть метод isSelected:
public function isSelected($option)
{
    return $option === $this->selected;
}
You may execute this method from your component template by invoking the variable matching the name of the method:
<option {{ $isSelected($value) ? 'selected="selected"' : '' }} value="{{ $value }}">
    {{ $label }}
</option>

41. Как получить доступ к имени компонента, атрибутам и слоту внутри метода рендеринга класса?
Однако для доступа к этим данным вы должны вернуть Closure из метода render вашего компонента. Closure получит массив $ data в качестве единственного аргумента:
public function render()
{
    return function (array $data) {
        // $data['componentName'];
        // $data['attributes'];
        // $data['slot'];

        return '<div>Components content</div>';
    };
}
ComponentName равно имени, используемому в теге HTML после префикса x-. Таким образом, имя компонента <x-alert /> будет alert. Элемент attributes будет содержать все атрибуты, которые присутствовали в теге HTML. Элемент slot - это экземпляр Illuminate \ Support \ HtmlString с содержимым слота из компонента.
Замыкание должно вернуть строку. Если возвращенная строка соответствует существующему представлению, это представление будет визуализировано; в противном случае возвращенная строка будет оцениваться как встроенное представление Blade.

42. Что такое слоты?


43. Что делать если компоненту требуются зависимости от сервис-контейнера Laravel?
Если вашему компоненту требуются зависимости от сервис-контейнера Laravel, вы можете указать их перед любыми атрибутами данных компонента, и они будут автоматически введены контейнером:
use App\Services\AlertCreator

/**
 * Create the component instance.
 *
 * @param  \App\Services\AlertCreator  $creator
 * @param  string  $type
 * @param  string  $message
 * @return void
 */
public function __construct(AlertCreator $creator, $type, $message)
{
    $this->creator = $creator;
    $this->type = $type;
    $this->message = $message;
}

44. Managing Attributes

45. Default / Merged Attributes
46. Non-Class Attribute Merging
47. Filtering Attributes

48. Как передать дополнительный контент через слоты?
Часто вам нужно будет передать дополнительный контент вашему компоненту через «слоты». Представим, что созданный нами компонент alert имеет следующую разметку:
<!-- /resources/views/components/alert.blade.php -->

<div class="alert alert-danger">
    {{ $slot }}
</div>
Мы можем передавать контент в slot, вставляя контент в компонент:
<x-alert>
    <strong>Whoops!</strong> Something went wrong!
</x-alert>
Иногда компоненту может потребоваться отобразить несколько разных слотов в разных местах внутри компонента. Давайте изменим наш компонент предупреждений, чтобы учесть добавление «заголовка»:
<!-- /resources/views/components/alert.blade.php -->

<span class="alert-title">{{ $title }}</span>

<div class="alert alert-danger">
    {{ $slot }}
</div>
Вы можете определить содержимое названного слота, используя тег x-slot. Любой контент, не входящий в тег x-slot, будет передан компоненту в переменной $ slot:
<x-alert>
    <x-slot name="title">
        Server Error
    </x-slot>

    <strong>Whoops!</strong> Something went wrong!
</x-alert>

49. Scoped Slots

50. Inline Component Views

51. Generating Inline View Components

52. Anonymous Components
53. Data Properties / Attributes
54. Dynamic Components
55. Including Subviews
56. и так далее до локализации

57. 
58. 
59.
60.
61.
62.
63.
64.
65.
66.
67.
68.
69.
70.
71.
72.
73.
74.
75.
76.
77.
78.
79.
80.
81.
82.
83.
84.
85.
86.
87.
88.
89.
90.
91.
92.
93.
94.
95.
96.
97.
98.
99.
100.
=======================================================================================

---------------------------------------------------------------------------------------
1.Локализация в ларавель
Возможности локализации Laravel предоставляют удобный способ получения строк на нескольких языках, что позволяет легко организовать поддержку мультиязычности вашим приложением. 

2. Где хранятся языковые строка 
внутри директории resources/lang

3. Что можете сказать о хранение языковых строк в resources/lang?
В ней должны находиться подпапки для каждого языка, поддерживаемого вашим приложением:
/resources
    /lang
        /en
            messages.php
        /es
            messages.php

4. Что возвращают языковые файлы?
массив строк с ключами.
return [
    'welcome' => 'Welcome to our application',
];

5. Если языки различаются по территори?
Для языков, которые различаются по территории, вы должны назвать языковые каталоги в соответствии с ISO 15897. Например, для британского английского следует использовать «en_GB», а не «en-gb».

6. Где указан стандартный язык вашего приложения?
Стандартный язык вашего приложения указан в конфиге config/app.php.

7. Как изменить активный язык в процессе работы приложения? (то есть не в конфиге)
Вы также можете изменить активный язык в процессе работы приложения с помощью метода setLocale фасада App:
Route::get('welcome/{locale}', function ($locale) {
    if (! in_array($locale, ['en', 'es', 'fr'])) {
        abort(400);
    }

    App::setLocale($locale);

    //
});

8. Как настроить запасной язык и что это такое?
Вы можете настроить «запасной язык», который будет использоваться, когда активный язык не содержит заданной строки перевода. Как и язык по умолчанию, резервный язык также настраивается в файле конфигурации config / app.php:
'fallback_locale' => 'en',

9. Как определить текущию локаль?
Вы можете использовать методы getLocale и isLocale на фасаде App, чтобы определить текущий языковой стандарт или проверить, является ли языковой стандарт заданным значением:
$locale = App::getLocale();

if (App::isLocale('en')) {
    //
}

10. Использование строк перевода как ключей?
Определение каждой строки с помощью "краткого ключа" для приложений с большими требованиями к переводу может привести к путанице при обращении к ним из ваших шаблонов. По этой причине, Laravel также предоставляет поддержку определения строк перевода с использованием стандартного перевода в качестве ключа.
Файлы переводов, которые используют строки перевода в качестве ключей, хранятся в JSON-файлах в директории resources/lang. Например, если приложение имеет поддержку испанского языка, то вы должны создать файл resources/lang/es.json:

{
    "I love programming.": "Me encanta programar."
}

11. Как получить строки перевода?
Вы можете получать строки из языковых файлов с помощью функции __. Она принимает файл и ключ строки перевода в качестве первого параметра. Например, давайте получим строку перевода welcome из языкового файла resources/lang/messages.php:
echo __('messages.welcome');
echo __('I love programming.');
Если вы используете шаблонизатор Blade, вы можете использовать синтаксис {{}} для вывода строки перевода или использовать директиву @lang:
{{ __('messages.welcome') }}

@lang('messages.welcome')
Если указанная строка перевода не существует, функция __ вернет ключ строки перевода. Итак, используя приведенный выше пример, функция __ вернет messages.welcome, если строка перевода не существует.
Директива @lang не выводит никаких сообщений. Вы несете полную ответственность за экранирование собственного вывода при использовании этой директивы.

12. Как подставить параметры в строках перевода?
При желании, вы можете указывать плейсхолдеры в ваших строках перевода. Все плейсхолдеры начинаются с символа :. Например, вы можете создать приветственное сообщение с плейсхолдером для имени:
'welcome' => 'Welcome, :name',
Для замены плейсхолдеров, при получении строки перевода, передайте массив с необходимыми заменами в качестве второго параметра функции __:
echo __('messages.welcome', ['name' => 'dayle']);
Если ваш плейсхолдер содержит только прописные буквы, или только первая его буква является прописной, то переведённое значение будет преобразовано соответствующим образом:
'welcome' => 'Welcome, :NAME', // Welcome, DAYLE
'goodbye' => 'Goodbye, :Name', // Goodbye, Dayle

13. Как справляться с такой проблемой плюрализация
Плюрализация является комплексной проблемой, так как в разных языках существуют различные сложные правила плюрализации. С помощью символа "вертикальной черты" вы можете разграничить одиночную и множественную форму строки:
'apples' => 'There is one apple|There are many apples',
Вы даже можете создать сложные правила плюрализации, которые определят строки перевода для нескольких диапазонов чисел:
'apples' => '{0} There are none|[1,19] There are some|[20,*] There are many',
После определения строки перевода с вариантами плюрализации, вы можете использовать функцию trans_choice для получения строки для заданного "числа". В данном примере, так как число больше нуля и единицы, была возвращена форма множественного числа этой строки:
echo trans_choice('messages.apples', 10);
Вы также можете определить атрибуты заполнителя в строках множественного числа. Эти заполнители можно заменить, передав массив в качестве третьего аргумента функции trans_choice:
'minutes_ago' => '{1} :value minute ago|[2,*] :value minutes ago',

echo trans_choice('time.minutes_ago', 5, ['value' => 5]);
Если вы хотите отобразить целочисленное значение, переданное в функцию trans_choice, вы можете использовать заполнитель: count:
'apples' => '{0} There are none|{1} There is one|[2,*] There are :count',

14.  Переопределение языковых файлов пакета
15.
16.
17.
18.
19.
20.
21.
22.
23.
24.
25.
26.
27.
28.
29.
30.
21.
22.
23.
24.
25.
26.
27.
28.
29.
30.
31.
32.
33.
34.
35.
36.
37.
38.
39.
40.
41.
42.
43.
44.
45.
46.
47.
48.
49.
50.
51.
52.
53.
54.
55.
56.
57.
58.
59.
60.
61.
62.
63.
64.
65.
66.
67.
68.
69.
70.
71.
72.
73.
74.
75.
76.
77.
78.
79.
80.
81.
82.
83.
84.
85.
86.
87.
88.
89.
90.
91.
92.
93.
94.
95.
96.
97.
98.
99.
100.
=======================================================================================
Сборка фронтенда
---------------------------------------------------------------------------------------
1.  Что такое Laravel Mix?
Laravel Mix - это чистый и гибкий API для определения инструкций сборки Webpack для вашего Laravel-приложения с использованием нескольких основных препроцессоров CSS и JavaScript. С помощью сцепки методов вы можете гибко определить свой конвейер сборки. Например:
mix.js('resources/js/app.js', 'public/js')
    .sass('resources/sass/app.scss', 'public/css');

2. Тут вопросы по webpack должны быть))

3. Обязательно ли использовать Laravel mix, который использует webpack для сборки фронта?
нет, можно вообще никакой не использовать.

4. Что нужно для работы Mix?
Node.js и NPM и Laravel Mix
вы можете легко установить последнюю версию Node и NPM с помощью простых графических установщиков со страницы загрузки.
Последний оставшийся шаг - установить Laravel Mix. В свежей установке Laravel вы найдете файл package.json в корне вашей структуры директорий. Файл package.json по умолчанию включает все необходимое, чтобы начать. Подумайте об этом как о вашем файле composer.json, кроме того, что он определяет Node-зависимости вместо PHP. Вы можете установить зависимости, запустив:
npm install

5. Как запустить mix?
Mix - это слой настройки поверх Webpack, поэтому для запуска задач Mix вам нужно только выполнить один из NPM-скриптов, который включен в файл Laravel package.json по умолчанию:
// Run all Mix tasks...
npm run dev

// Run all Mix tasks and minify output...
npm run production

6. Как ослеживать изменения статики? 
Команда npm run watch продолжит выполняться в терминале и будет следить за всеми изменениями ваших ресурсов. Когда что-либо изменится, автоматически скомпилируются новые файлы:
npm run watch
Вы можете обнаружить, что в определенных средах Webpack не обновляется, когда меняются ваши файлы. Если это как раз то, с чем вы столкнулись, попробуйте использовать команлу watch-poll:
npm run watch-poll

7. Работа с таблицами стилей
Файл webpack.mix.js - ваша точка входа для компиляции всех ассетов. Считайте его легкой оболочкой для настройки поверх Webpack. Задачи Mix можно связать вместе, чтобы конкретно указать как должны компилироваться ваши ассеты.

8. Less
9. Sass
10. Stylus
11. PostCSS
12. Простой CSS
13. и до конца
14.
15.
16.
17.
18.
19.
20.
21.
22.
23.
24.
25.
26.
27.
28.
29.
30.
21.
22.
23.
24.
25.
26.
27.
28.
29.
30.
31.
32.
33.
34.
35.
36.
37.
38.
39.
40.
41.
42.
43.
44.
45.
46.
47.
48.
49.
50.
51.
52.
53.
54.
55.
56.
57.
58.
59.
60.
61.
62.
63.
64.
65.
66.
67.
68.
69.
70.
71.
72.
73.
74.
75.
76.
77.
78.
79.
80.
81.
82.
83.
84.
85.
86.
87.
88.
89.
90.
91.
92.
93.
94.
95.
96.
97.
98.
99.
100.
